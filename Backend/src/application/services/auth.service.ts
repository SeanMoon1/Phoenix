import {
  Injectable,
  UnauthorizedException,
  BadRequestException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from './users.service';
import { TeamsService } from './teams.service';
import { LoginDto } from '../../presentation/dto/login.dto';
import { RegisterDto } from '../../presentation/dto/register.dto';
import { OAuthRegisterDto } from '../../presentation/dto/oauth-register.dto';
import { PasswordUtil } from '../../utils/password.util';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private teamsService: TeamsService,
    private jwtService: JwtService,
  ) {}

  async validateUser(email: string, password: string): Promise<any> {
    const user = await this.usersService.findByEmail(email);
    if (user && (await PasswordUtil.comparePassword(password, user.password))) {
      const { password, ...result } = user;
      return result;
    }
    return null;
  }

  async login(user: any) {
    const payload = { email: user.email, sub: user.id };
    return {
      access_token: this.jwtService.sign(payload),
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
        userLevel: user.userLevel,
        currentTier: user.currentTier,
      },
    };
  }

  /**
   * 회원가입 (팀 코드 없이)
   * @param registerDto 회원가입 정보
   * @returns 생성된 사용자 정보
   */
  async register(registerDto: RegisterDto) {
    try {
      // 1. 비밀번호 강도 검사 (길이 중심)
      const passwordStrength = PasswordUtil.getPasswordStrength(
        registerDto.password,
      );
      if (passwordStrength.score < 4) {
        // 최소 점수 4 (12자 + 소문자 + 숫자)
        throw new BadRequestException({
          message: '비밀번호가 너무 약합니다.',
          feedback: passwordStrength.feedback,
        });
      }

      // 2. 비밀번호 해시화
      const hashedPassword = await PasswordUtil.hashPassword(
        registerDto.password,
      );

      // 3. 사용자 생성 (팀 ID는 null로 설정)
      const user = await this.usersService.create({
        ...registerDto,
        teamId: null, // 팀 코드 없이 가입
        userCode: null, // 사용자 코드는 나중에 설정
        password: hashedPassword,
      });

      const { password, ...result } = user;
      return result;
    } catch (error) {
      throw error;
    }
  }

  /**
   * OAuth 회원가입 및 로그인 (자동 사용자 ID 생성)
   * @param oauthRegisterDto OAuth 회원가입 정보
   * @returns JWT 토큰과 사용자 정보
   */
  async oauthRegisterAndLogin(oauthRegisterDto: OAuthRegisterDto) {
    try {
      // 1. 이미 존재하는 사용자인지 확인 (이메일 또는 OAuth 제공자 ID로)
      let user = await this.usersService.findByEmail(oauthRegisterDto.email);

      if (!user) {
        // 2. OAuth 제공자 ID로도 확인
        user = await this.usersService.findByOAuthProvider(
          oauthRegisterDto.provider,
          oauthRegisterDto.providerId,
        );
      }

      if (!user) {
        // 3. 새 사용자 생성 (자동으로 사용자 ID 생성)
        const autoGeneratedLoginId = await this.generateUniqueLoginId(
          oauthRegisterDto.email,
        );

        user = await this.usersService.create({
          loginId: autoGeneratedLoginId,
          name: oauthRegisterDto.name,
          email: oauthRegisterDto.email,
          password: '', // OAuth 사용자는 비밀번호 없음
          teamId: null, // 팀은 나중에 가입
          userCode: null, // 사용자 코드는 나중에 생성
          oauthProvider: oauthRegisterDto.provider,
          oauthProviderId: oauthRegisterDto.providerId,
          profileImageUrl: oauthRegisterDto.profileImage,
        });
      } else {
        // 4. 기존 사용자 정보 업데이트 (OAuth 정보 추가)
        user.oauthProvider = oauthRegisterDto.provider;
        user.oauthProviderId = oauthRegisterDto.providerId;
        user.profileImageUrl = oauthRegisterDto.profileImage;
        user = await this.usersService.update(user.id, user);
      }

      // 5. JWT 토큰 생성 및 반환
      const payload = { email: user.email, sub: user.id };
      return {
        access_token: this.jwtService.sign(payload),
        user: {
          id: user.id,
          teamId: user.teamId,
          userCode: user.userCode,
          loginId: user.loginId,
          email: user.email,
          name: user.name,
          useYn: user.useYn,
          userLevel: user.userLevel,
          userExp: user.userExp,
          totalScore: user.totalScore,
          completedScenarios: user.completedScenarios,
          currentTier: user.currentTier,
          levelProgress: user.levelProgress,
          nextLevelExp: user.nextLevelExp,
          isActive: user.isActive,
          oauthProvider: user.oauthProvider,
          profileImageUrl: user.profileImageUrl,
          createdAt: user.createdAt,
          updatedAt: user.updatedAt,
        },
      };
    } catch (error) {
      throw error;
    }
  }

  /**
   * 로그인 ID 중복 확인
   * @param loginId 확인할 로그인 ID
   * @returns 중복 확인 결과
   */
  async checkLoginIdAvailability(loginId: string) {
    try {
      const existingUser = await this.usersService.findByLoginId(loginId);

      return {
        success: true,
        data: {
          available: !existingUser,
          message: existingUser
            ? '이미 사용 중인 로그인 ID입니다.'
            : '사용 가능한 로그인 ID입니다.',
        },
      };
    } catch (error) {
      return {
        success: false,
        error: '로그인 ID 확인 중 오류가 발생했습니다.',
      };
    }
  }

  /**
   * 고유한 로그인 ID 생성
   * @param email 이메일 주소
   * @returns 고유한 로그인 ID
   */
  private async generateUniqueLoginId(email: string): Promise<string> {
    // 이메일에서 @ 앞부분을 기본값으로 사용
    const baseId = email.split('@')[0].toLowerCase();
    let loginId = baseId;
    let counter = 1;

    // 고유한 ID가 될 때까지 반복
    while (await this.usersService.findByLoginId(loginId)) {
      loginId = `${baseId}${counter}`;
      counter++;
    }

    return loginId;
  }
}
